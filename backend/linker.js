require("format-unicorn");
var schema = require("./schema");
"use strict";


/**
* Confirms that the provided node is of the required type.
* @param {Object} node The node to typecheck.
* @param {string} type The type requirement of the node.
* @return {boolean} true if the types are the same, false otherwise.
*/
function typecheck(node, type) {
  switch(node.type) {
    case "if":
      return typecheck(node.then, type) && ((node.else == undefined) ? true : typecheck(node.else, type));

    case "as":
      return type == node.conversion;

    case "method":
      return type == node.return;

    default:
      return type == node.type;
  }
};


/**
* Compiles an HDQL linked-context-tree from the provided parse-tree, schema, and root context.
* @param {Object} tree A parse-subtree, generated by "praser.js".
* @param {function(string|null, Object|null): ?} callback The callback to call with the results.
* @return {?} The return value of the callback.
*/
function linkTree(tree, callback) {
  switch(tree.type) {
    case "if":
      // Recurse through the "IF ... THEN ... [ELSE] ... FI" proceedure:
      return linkTree(tree.conditional, function(err, res) {
        if(err !== null)
          return callback(err, null);
        return linkTree(tree.then, function(err2, res2) {
          if(err2 !== null)
            return callback(err, null);
          if(tree.else != undefined)
            return linkTree(tree.else, function(err3, res3) {
              if(err3 !== null)
                return callback(err3, null);
              return callback(null, { type: "tree", conditional: res, then: res2, else: res3 });
            });
          return callback(null, { type: "tree", conditional: res, then: res2 });
        });
      });

    case "as":
      // Recurse through the "... AS ..." proceedure
      return linkTree(tree.val, function(err, res) {
        if(err !== null)
          return callback(err, null);
        return callback(null, { type: tree.conversion, val: res });
      });

    case "method":
      // Recurse through the "method" proceedure:
      let template = schema.functions[tree.name];
      if(template == undefined)
        return callback("Unknown method \"" + tree.name + "\"", null);
      // Check for parameter length equality:
      if(tree.params.length !== template.params.length)
        return callback("Mismatched parameter lengths in method call to \"" + tree.name + "\"", null);
      // Recurse through the parameters:
      for(let i = 0; i < tree.params.length; ++i) {
        let tmpErr = linkTree(tree.params[i], function(err, res) {
          tree.params[i] = res;
          return err;
        });
        if(tmpErr !== null)
          return callback(tmpErr, null);
      }
      // Typecheck all parameters:
      for(let i = 0; i < tree.params.length; ++i) {
        let matched = false;
        for(let j = 0; j < template.params[i].length; ++j)
          if(typecheck(tree.params[i], template.params[i][j])) {
            matched = true;
            break;
          }
        if(!matched)
          return callback("Mismatched parameter types in call to \"" + tree.name + "\", [" + i + "]", null);
      }
      // Run the callback:
      tree.returns = template.returns;
      tree.english = template.english;
      tree.exec = template.exec;
      return callback(null, tree);

    case "var":
      // Link all "var" proceedures:
      let temp = schema.vars[tree.name];
      if(temp == undefined)
        return callback("Unknown variable \"" + tree.name + "\"", null);
      tree.type = temp.type;
      tree.english = temp.english;
      tree.getter = temp.getter;
      return callback(null, tree);

    case "int":
    case "double":
    case "string":
      // No need to do anything for any of these types:
      return callback(null, tree);

    default:
      // Failed to process ...
      return callback("unrecognised type \"" + tree.type + "\"", null);
  }
}


/**
* Compiles an HDQL linked-context-forest from the provided parse-forest, schema, and root context.
* @param {Object} forest A parse-forest, generated by "praser.js".
* @param {?} context A context object which will be employed by the executor when running the program.
* @param {function(string|null, Object|null)} callback The callback to call with the results.
* @return {?} The return value of the callback.
*/
function linkForest(forest, context, callback) {
  let out = { context: context, forest: [] };

  // Parse all of the trees:
  forest.forEach((tree) => {
    out.forest.push(linkTree(tree, function(err, res) {
      if(err !== null)
        return callback(err, null);
      out.forest.push(res);
    }));
  });

  return callback(null, out);
}

// Export the forest-linker:
module.exports = linkForest;
